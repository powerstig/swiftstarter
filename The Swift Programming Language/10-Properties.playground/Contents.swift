// Properties

// Stored Properties
struct FixedLengthRange {
  var firstValue: Int
  let length: Int
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
rangeOfThreeItems.firstValue = 6


// Stored Properties of Constant Structure Instances
//  If you create an instance of a structure and assign that instance to a constant, you cannot modify the instance’s properties, even if they were declared as variable properties:
let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)
//rangeOfFourItems.firstValue = 6
// The above line will report and error, even though firstValue is a variable property


// 延迟存储属性 Lazy Stored Properties
// 延迟存储属性的初始值在其第一次使用时才进行计算。你可以通过在其声明前标注 lazy 修饰语来表示一个延迟存储属性。
class DataImporter {
  /*
   DataImporter is a class to import data from an external file.
   The class is assumed to take a non-trivial amount of time to initialize
   */
  var fileName = "data.txt"
  // the Data Importer class would provide data importing functionality here
}

class DataManager {
  lazy var importer = DataImporter()
  var data = [String]()
  // the DataManager class would provide data management functionality here
}

let manager = DataManager()
manager.data += ["Some data"]
manager.data += ["Some more data"]
// the DataImporter instance for the importer property has not yet been created
print(manager.data)
print(manager.importer.fileName)
// the DataImporter instance for the importer property has now been created


// 计算属性 Computed Properties
struct Point {
  var x = 0.0, y = 0.0
} // Point 封装了一个 (x,y) 坐标;
struct Size {
  var width = 0.0, height = 0.0
} // Size 封装了一个 width 和 height ;
struct Rect { // Rect 封装了一个长方形包括原点和大小。
  var origin = Point()
  var size = Size()
  var center: Point {
    get {
      let centerX = origin.x + (size.width / 2)
      let centerY = origin.y + (size.height / 2)
      return Point(x: centerX, y: centerY)
    } // 读取器（ getter ）
    set(newCenter) {
      origin.x = newCenter.x - (size.width / 2)
      origin.y = newCenter.y - (size.height / 2)
    } // 设置器（ setter ）
  }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0), size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
print("square.origin is now at (\(square.origin.x), \(square.origin.y))")

// 简写设置器（setter）声明 Shorthand Setter Declaration
// If no name is given for the new value a variable of name newValue is autogenerated
struct AlternativeRect {
  var origin = Point()
  var size = Size()
  var center: Point {
    get {
      let centerX = origin.x + (size.width / 2)
      let centerY = origin.y + (size.height / 2)
      return Point(x: centerX, y: centerY)
    }
    set {
      origin.x = newValue.x - (size.width / 2)
      origin.y = newValue.y - (size.height / 2)
    } // 简写设置器声明
  }
}
// 简写读取器（getter）声明
// ？？ 如果整个 getter 的函数体是一个单一的表达式，那么 getter 隐式返回这个表达式
struct CompactRect {
  var origin = Point()
  var size = Size()
  var center: Point {
    
    get {
      return Point(x: origin.x + (size.width / 2),
                   y: origin.y + (size.height / 2))
    }
    
    set {
      origin.x = newValue.x - (size.width / 2)
      origin.y = newValue.y - (size.height / 2)
    }
  }
}

// 只读计算属性 Read only Computed Properties
// 一个有读取器但是没有设置器的计算属性就是所谓的只读计算属性。
struct Cuboid {
  var width = 0.0, height = 0.0, depth = 0.0
  var volume: Double {
    return width * height * depth
  }
}
let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)
print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")


// 属性观察者 Property Observers
class StepCounter {
  var totalSteps: Int = 0 {
    willSet(newTotalSteps) {
      print("About to set totalSteps to \(newTotalSteps)")
    } // willSet 会在该值被存储之前被调用。
    // 如果你实现了一个 willSet 观察者，新的属性值会以常量形式参数传递。
    // 可以在 willSet 实现中为这个参数定义名字。如果你没有为它命名，那么它会使用默认的名字 newValue 。
    
    didSet {
      if totalSteps > oldValue {
        print("Added \(totalSteps - oldValue) steps")
      }
    } // didSet 会在一个新值被存储后被调用。
    
  }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
stepCounter.totalSteps = 360
stepCounter.totalSteps = 896


// Type Properties
//  Type properties are useful for defining values that are universal to all instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that is global to all instances of that type (like a static variable in C).

// 类型属性 Type Property Syntax
struct SomeStructure {
  static var storedTypeProperty = "Some value."
  static var computedTypeProperty: Int {
    return 1
  }
}

enum SomeEnumeration {
  static var storedTypeProperty = "Some value."
  static var computedTypeProperty: Int {
    return 6
  }
}

class SomeClass {
  static var storedTypeProperty = "Some value."
  static var computedTypeProperty: Int {
    return 27
  }
  class var overrideableComputedTypeProperty: Int {
    return 107
  }
}

// 查询和设置类型属性 Querying and setting Type Properties
print(SomeStructure.storedTypeProperty)             // prints "Some value."
SomeStructure.storedTypeProperty = "Another value."
print(SomeStructure.storedTypeProperty)             // prints "Another value."
print(SomeEnumeration.computedTypeProperty)         // prints "6"
print(SomeClass.computedTypeProperty)               // prints "27"


// 两个存储类型属性作为建模一个为数字音频信道音频测量表的结构体的一部分。
// 每一个频道都有一个介于 0 到 10 之间的数字音频等级。
struct AudioChannel {
  static let thresholdLevel = 10
  static var maxInputLevelForAllChannels = 0
  var currentLevel: Int = 0 {
    didSet {
      if currentLevel > AudioChannel.thresholdLevel {
        // cap the new audio level to the threshold level
        currentLevel = AudioChannel.thresholdLevel
      }
      if currentLevel > AudioChannel.maxInputLevelForAllChannels {
        // store this as the new overall maximum input level
        AudioChannel.maxInputLevelForAllChannels = currentLevel
      }
    }
  }
}
var leftChannel = AudioChannel()
var rightChannel = AudioChannel()
leftChannel.currentLevel = 7
print(leftChannel.currentLevel)
print(AudioChannel.maxInputLevelForAllChannels)
rightChannel.currentLevel = 11
print(rightChannel.currentLevel)
print(AudioChannel.maxInputLevelForAllChannels)




